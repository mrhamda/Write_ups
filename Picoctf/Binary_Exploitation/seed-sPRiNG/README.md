# Write-up of the challenge "seed-sPRiNG"

This challenge is part of the "Binary exploitation" category and is in the hard category.

# Goal of the challenge

The objective of the challenge is just to input the correct random number 30 times in a row to get the flag.

## Program structure

```c

int32_t main(int32_t argc, char** argv, char** envp)
{
    void* const __return_addr_1 = __return_addr;
    int32_t* var_10 = &argc;
    puts(0x10a50);
    puts(0x10a50);
    puts("                                                                             ");
    puts("                          #                mmmmm  mmmmm    "    mm   m   mmm ");
    puts("  mmm    mmm    mmm    mmm#          mmm   #   "# #   "# mmm    #"m  # m"   "");
    puts(" #   "  #"  #  #"  #  #" "#         #   "  #mmm#" #mmmm"   #    # #m # #   mm");
    puts("  """m  #""""  #""""  #   #          """m  #      #   "m   #    #  # # #    #");
    puts(" "mmm"  "#mm"  "#mm"  "#m##         "mmm"  #      #    " mm#mm  #   ##  "mmm"");
    puts("                                                                             ");
    puts(0x10a50);
    puts(0x10a50);
    puts("Welcome! The game is easy: you jump on a sPRiNG.");
    puts("How high will you fly?");
    puts(0x10a50);
    fflush(*stdout);
    srand(time(nullptr));
    int32_t var_14 = 1;
    
    while (true)
    {
        if (var_14 > 0x1e)
        {
            puts("Congratulation! You've won! Here is your flag:\n");
            fflush(*stdout);
            get_flag();
            fflush(*stdout);
            return 0;
        }
        
        printf("LEVEL (%d/30)\n", var_14);
        puts(0x10a50);
        int32_t eax_4 = rand() & 0xf;
        printf("Guess the height: ");
        fflush(*stdout);
        int32_t var_20;
        __isoc99_scanf("%d", &var_20);
        fflush(*stdin);
        
        if (eax_4 != var_20)
            break;
        
        var_14 += 1;
    }
    
    puts("WRONG! Sorry, better luck next time!");
    fflush(*stdout);
    exit(0xffffffff);
    /* no return */
}

```

## Problem

Actually this part of the challenge was pretty easy. I did a lot of ctfs and it is not the first time I am asked to predict **"srand"**.


## Security breach

So this is a very common security vulnerability **"srand(time(nullptr));"**. Srand is based on the current timestamp and that's bad because an attacker can predict the srand because they can just take the current time and use srand(current_time).

## Solution
In the end I just got t by predicating the current timestamp. After that we used the libc to be able to call srand. As we saw in the decompiler we need to also **"&0xf"** 
the srand to get the correct value.
**"int32_t eax_4 = rand() & 0xf;"**.

```python
from pwn import *
import ctypes

p = remote('fickle-tempest.picoctf.net', 52686)
# p = process('./seed_spring')

t = int(time.time())
libc = ctypes.CDLL("libc.so.6")
libc.srand(t)

for i in range(30):
    ans = (libc.rand() & 0xf)
    p.sendline(str(ans).encode())

p.interactive()

```

After excuting the script we get the flag back!

If you liked this writeup you can star my repository.