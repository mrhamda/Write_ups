# Write-up of the challenge "Log folly"

This challenge is part of the "Cryptography" category and is woth 79 points.

# Goal of the challenge

The challenge involves a system that leaks modular exponentiations of a rotating flag. Given a prime p, generator g = 2, and flag FLAG, the system computes h = g^x mod p for each byte rotation of the flag and leaks these values.

## Program structure

Chall.py:
```
from Crypto.Util.number import getPrime, bytes_to_long
from secret import FLAG

def rotate(s):
    return s[1:] + s[:1]

p = getPrime(256)
g = 2

print('p: ', p)
for _ in range(len(FLAG)):
    x = bytes_to_long(FLAG.encode())
    h = pow(g, x, p)
    print('leak: ', h)
    FLAG = rotate(FLAG)

```

output.txt:
```
p:  105891552782768273485439811488443354235545023673195353053856843893816480862271
leak:  74834831693148489075053741970537349864361072646438063822128523522624111096404
leak:  94637262384206414487913618520407895315549149001067603290715492338419957063638
leak:  26119415647812686814124878968032828750956202141747974248626227495752618826310
leak:  4679774184271053791528196045893972569586759227111353536533198888487507918565
leak:  18247264710550364407701539407739806326963229364366084285259750379893601861765
leak:  57915316904508068959154652733100932636576891111709785240327600448742235657223
leak:  48726379408397107751482798948037834170753506073391626907440435722452593080790
leak:  23985113650578780235980433910057970681859494895610853985857472866552793069375
leak:  79231016211481853602891211467430186947199626871048819648312025046281485147965
leak:  1741002057862179063516105232753064091765321308410446556962767548042727938590
leak:  45723548930603031191234669145592632467258468694483505689072179691228438466667
leak:  58359671511194341930052508512801343119287048085288142869480583778613556216586
leak:  36424897628935082604512568766716569943269039796337573854278402880102811617963
leak:  74124749341279711257845847090110538409556405630352757105373182076739304300759
leak:  66309699088883552645305984224828051437638962884903042514430099711503266344026
leak:  3162806651485565481013375199103880408462676315825209573632289159416883750178
leak:  38582718538740737041784799604514668813686704870272183643601445048856770639975
leak:  60816150467494956825800367310063997854145812297158134406617773585762215516843
leak:  12353526085228982771214476339845069964525380861405349768474892062968628975241
leak:  105582281937486445268146775233874434792742700624750876452894760571703935174919
leak:  13238662997179930853908762356537888264584682314391321882412877512234731316348
leak:  75875040959123636492014257513993145046661183624855640826292741601485403285328
leak:  12149947150174642792165286320748309835337741992502616190760701133669565860666
leak:  38650263185329843052214216132708910216830022007692554045491912295950867554552
leak:  92561547647296020081423003558701351791204280991353765906671600253604516771598
leak:  41349557324733447344437570514434312589869408427300508224464407246422794992797
leak:  86385180739170312287865404316483035605934760491085055759657242983443484861082
leak:  39348401982172687025128116440936094277482944374061555213943911942008513049037
leak:  58273481812023054183980778217247474508696785731672888895966172242039774561634
leak:  69932445711823749013619544296257448424270930795659726110506648765574551496961
leak:  11196151841801624492550269516119227591456953234837751240484968196644961160377
leak:  26041577455573938646072969268840197244828691423833869416465901173451675328995

```

## Security breach

The vulnerability stems from the predictable mathematical relationship between consecutive rotations of the flag. When a byte string is rotated, its integer representation changes in a linear fashion:

```x_{i+1} = 256·x_i - K·b_i```

## Solution
We exploit the mathematical relationship between consecutive flag rotations. The rotation creates a linear relation between integer representations: **x_{i+1} = 256·x_i - K·b_i**, where **K = 256^m - 1** and **b_i** are flag bytes. In the exponent domain, this becomes **h_{i+1} = h_i^{256} · A^{b_i} mod p** with **A = 2^{-K} mod p**. We solve **A^{b_i} = h_{i+1} · h_i^{-256} mod p** for each byte **b_i by brute force (0-255)**. Reconstructing all bytes gives the flag!

```
from Crypto.Util.number import long_to_bytes

p = 105891552782768273485439811488443354235545023673195353053856843893816480862271
leaks = [74834831693148489075053741970537349864361072646438063822128523522624111096404,94637262384206414487913618520407895315549149001067603290715492338419957063638,26119415647812686814124878968032828750956202141747974248626227495752618826310,4679774184271053791528196045893972569586759227111353536533198888487507918565,18247264710550364407701539407739806326963229364366084285259750379893601861765,57915316904508068959154652733100932636576891111709785240327600448742235657223,48726379408397107751482798948037834170753506073391626907440435722452593080790,23985113650578780235980433910057970681859494895610853985857472866552793069375,79231016211481853602891211467430186947199626871048819648312025046281485147965,1741002057862179063516105232753064091765321308410446556962767548042727938590,45723548930603031191234669145592632467258468694483505689072179691228438466667,58359671511194341930052508512801343119287048085288142869480583778613556216586,36424897628935082604512568766716569943269039796337573854278402880102811617963,74124749341279711257845847090110538409556405630352757105373182076739304300759,66309699088883552645305984224828051437638962884903042514430099711503266344026,3162806651485565481013375199103880408462676315825209573632289159416883750178,38582718538740737041784799604514668813686704870272183643601445048856770639975,60816150467494956825800367310063997854145812297158134406617773585762215516843,12353526085228982771214476339845069964525380861405349768474892062968628975241,105582281937486445268146775233874434792742700624750876452894760571703935174919,13238662997179930853908762356537888264584682314391321882412877512234731316348,75875040959123636492014257513993145046661183624855640826292741601485403285328,12149947150174642792165286320748309835337741992502616190760701133669565860666,38650263185329843052214216132708910216830022007692554045491912295950867554552,92561547647296020081423003558701351791204280991353765906671600253604516771598,41349557324733447344437570514434312589869408427300508224464407246422794992797,86385180739170312287865404316483035605934760491085055759657242983443484861082,39348401982172687025128116440936094277482944374061555213943911942008513049037,58273481812023054183980778217247474508696785731672888895966172242039774561634,69932445711823749013619544296257448424270930795659726110506648765574551496961,11196151841801624492550269516119227591456953234837751240484968196644961160377,26041577455573938646072969268840197244828691423833869416465901173451675328995]

m = len(leaks)
K = 256**m - 1
A = pow(2, -K, p)

flag_bytes = []
for i in range(m):
    t = (leaks[(i+1)%m] * pow(leaks[i], -256, p)) % p
    flag_bytes.append(next(j for j in range(256) if pow(A, j, p) == t))

print(''.join(chr(b) for b in flag_bytes))


```

If you liked this writeup you can star my repository.